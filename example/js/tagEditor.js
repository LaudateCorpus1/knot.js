/*
   tagEditor put the editor HTML and relevant CBS options in tagEditor.cbs, which is marked as private.
   The HTML in private CBS is referenced as a template
   tagEditor creates the UI and adds it to it's owner, then bind the UI to a proxy object which is "TagEditorModel"
   TagEditorModel receives the tags string from AP Provider, parse it into separated tags so that UI can present them correctly.
   And when UI changes the tags, TagEditorModel notify system and generate the new tags string
* */
(function (global) {
    "use strict";
    //tagEditor need to create a special APProvider to support access point for "knot-example-tagEditor"
    var APProvider = {
        //only support "knot-example-tagEditor" on DIV tag
        doesSupport: function (target, apName) {
            return (target instanceof  HTMLElement) && target.tagName.toLowerCase() === "div" &&
                    apName === "knot-example-tagEditor";
        },
        getValue: function (target, apName, options) {
            if(!target.tagEditorModel) {
                return null;
            }
            else {
                return target.tagEditorModel.getValue();
            }
        },

        setValue: function (target, apName, value, options) {
            if(!target.tagEditorModel) {
                //create the proxy model and attach it to the UI element created from template
                target.tagEditorModel = new TagEditorModel();
                var ele = global.Knot.Advanced.createFromTemplate("knot-example-tagEditor", target.tagEditorModel, target);
                global.Knot.Advanced.setDataContext(ele, target.tagEditorModel);
                $(target).append(ele);

                //change the color for the tags
                ele.children[0].onTagEditorItemAdded = function (n) {
                    if(options && options.color) {
                        $(n).css("backgroundColor", options.color);
                    }
                };
            }
            target.tagEditorModel.setValue(value);
        },
        doesSupportMonitoring: function (target, apName) {
            return true;
        },
        monitor: function (target, apName, callback, options) {
            if(!target.tagEditorModel) {
                target.tagEditorModel = new TagEditorModel();
            }
            target.tagEditorModel.monitor(callback);
        },
        stopMonitoring: function (target, apName, callback, options) {
            if(!target.tagEditorModel) {
                return;
            }
            target.tagEditorModel.stopMonitoring(callback);
        }
    };

    //don't forget register the AP provider to make it alive
    global.Knot.Advanced.registerAPProvider(APProvider);

    //this function is to be attached to the tag object generated by TagEditorModel
    //so that it can be accessed by CBS knot options from current data context.
    //Another way to do it is put it into global scope and access it with absolute value path
    function onDeleteTag(eventArg, node) {
        var editor = $(node).closest(".knot-example-tagEditor");
        if(editor.length>0) {
            global.Knot.getDataContext(editor[0]).deleteTag(this);
        }
    }
    function createTag(name) {
        return {name:name, onDelete:onDeleteTag};
    }

    //this is the proxy object as well as the view model of tagEditor
    //it is bound to UI by the CBS defined in tagEditor.cbs
    var TagEditorModel = function () {
        this.tags = [];
        this._editor = null;
        this._changedCallbacks = [];
    };
    var p = TagEditorModel.prototype;
    p.setValue = function (value) {
        if(!value) {
            this.tags = [];
        }
        this.tags = value.split(",").map(function (t) {return createTag(t);});
    };
    p.getValue = function () {
        return this.tags.map(function (t) {return t.name;}).join(",");
    };

    p.raiseChangedEvent = function () {
        for(var i=0; i< this._changedCallbacks.length; i++) {
            this._changedCallbacks[i]();
        }
    };

    p.monitor = function (callback) {
        this._changedCallbacks.push(callback);
    };
    p.stopMonitoring = function (value) {
        this._changedCallbacks.splice(this._changedCallbacks.indexOf(value), 1);
    };

    p.deleteTag = function (tag) {
        if(this.tags.indexOf(tag) >= 0) {
            this.tags.splice(this.tags.indexOf(tag), 1);
            this.raiseChangedEvent();
        }
    };
    p.onAdd = function (arg, node) {
        var input  = $(node).closest(".knot-example-tagEditor").find("input");
        this.tags = this.tags.concat(input.val().split(",").map(function (t) {return createTag(t);}));
        input.val("");
        this.raiseChangedEvent();
    };


})(window);